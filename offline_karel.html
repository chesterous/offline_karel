<!DOCTYPE html>
<html>
    <head>
        <title>Offline Karel (one file Karel)</title>
        <style>
            textarea {
                white-space: pre;
                overflow-wrap: normal;
                overflow-x: scroll;
            }
        </style>
    </head>
    <body onload="setup()">
        <script>
            const styles = {
                "flower": {
                    empty_img: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABhWlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw1AUhU/TiiIVEYuIOmSoTnZREcdSxSJYKG2FVh1MXvoHTRqSFBdHwbXg4M9i1cHFWVcHV0EQ/AFxdnBSdJES70sKLWK88Hgf591zeO8+QGhUmGoGooCqWUYqHhOzuVWx+xUBjMKHIQxIzNQT6cUMPOvrnjqp7iI8y7vvz+pT8iYDfCJxlOmGRbxBPLtp6Zz3iUOsJCnE58STBl2Q+JHrsstvnIsOCzwzZGRS88QhYrHYwXIHs5KhEs8QhxVVo3wh67LCeYuzWqmx1j35C4N5bSXNdVpjiGMJCSQhQkYNZVRgIUK7RoqJFJ3HPPwjjj9JLplcZTByLKAKFZLjB/+D37M1C9NTblIwBnS92PbHONC9CzTrtv19bNvNE8D/DFxpbX+1Acx9kl5va+EjoH8buLhua/IecLkDDD/pkiE5kp+WUCgA72f0TTlg8BboXXPn1jrH6QOQoVkt3wAHh8BEkbLXPd7d0zm3f3ta8/sBb1lypWgHKyMAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfoBBsBLwfJ4YLoAAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAAIlJREFUOMulkz0OwCAIhdE4eLyOPaIjx9OJDkr8RWn7FhP0gxcBA2uREDenAAEAEGU+pf7a+5lrXxCDrbokWBLdlbU7eNKVjxiqWws/ZdXVB7GLrYPxEyUHy4dLGOeQe1NNdKAS/kmA8hX7phhqnzUgD5PTAqBYDiq9Paod5eUySYkKKC7Tp3V+AE8QMTCfSkf3AAAAAElFTkSuQmCC',
                    beeper_img: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABhWlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw1AUhU/TiiIVEYuIOmSoTnZREcdSxSJYKG2FVh1MXvoHTRqSFBdHwbXg4M9i1cHFWVcHV0EQ/AFxdnBSdJES70sKLWK88Hgf591zeO8+QGhUmGoGooCqWUYqHhOzuVWx+xUBjMKHIQxIzNQT6cUMPOvrnjqp7iI8y7vvz+pT8iYDfCJxlOmGRbxBPLtp6Zz3iUOsJCnE58STBl2Q+JHrsstvnIsOCzwzZGRS88QhYrHYwXIHs5KhEs8QhxVVo3wh67LCeYuzWqmx1j35C4N5bSXNdVpjiGMJCSQhQkYNZVRgIUK7RoqJFJ3HPPwjjj9JLplcZTByLKAKFZLjB/+D37M1C9NTblIwBnS92PbHONC9CzTrtv19bNvNE8D/DFxpbX+1Acx9kl5va+EjoH8buLhua/IecLkDDD/pkiE5kp+WUCgA72f0TTlg8BboXXPn1jrH6QOQoVkt3wAHh8BEkbLXPd7d0zm3f3ta8/sBb1lypWgHKyMAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfoBBsBLxU6WPOgAAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAAXZJREFUWMOtV7EVAjEIhXspbixLR7B0jBvBMSwdwdLSkeywkTMhhBAu6e4S4BPgExBii8Q3BvWEBGmmPowaJ/rjQMSwzhCA3LgCAkdClRzXPDNMJPXhYHxJ874RCleY0kB8ye2+ApKIKoAAAEtPmIjA8tpj3FppRDF7oHkSXWm4bjPjn8///7qW+/ImGlWiJ6EhXBjVFgMxcqlLGgUIj3E2yvsSRCNkqCUhtUoqV54b0JYEyoksbpYkAIpmvgri1ecGAKDkiT0r83o8UlGLxe8tY71cgLcfzOI++a4TbGj/EA88AeBse7iestg/3VyC2OoBVQluPxCnMsn4ez/DgG6+hoRWIyoSUVEu/2v7DR5wPR4qMroDwGXTr/XxM3qFyUyo1fJdEbo6uqIGwgWgBSTSkiWIxWvcoNTwWyDcjntUzWfmEtHgQwQRq/OafPJ4EHgB7fxitWIzCXuKg7OBay7AmbNfT/bQ0DFjPIt6Nm1APfq+PhyqL2nU2YRUjg5lAAAAAElFTkSuQmCC',
                    karel_img: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABhWlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw1AUhU/TiiIVEYuIOmSoTnZREcdSxSJYKG2FVh1MXvoHTRqSFBdHwbXg4M9i1cHFWVcHV0EQ/AFxdnBSdJES70sKLWK88Hgf591zeO8+QGhUmGoGooCqWUYqHhOzuVWx+xUBjMKHIQxIzNQT6cUMPOvrnjqp7iI8y7vvz+pT8iYDfCJxlOmGRbxBPLtp6Zz3iUOsJCnE58STBl2Q+JHrsstvnIsOCzwzZGRS88QhYrHYwXIHs5KhEs8QhxVVo3wh67LCeYuzWqmx1j35C4N5bSXNdVpjiGMJCSQhQkYNZVRgIUK7RoqJFJ3HPPwjjj9JLplcZTByLKAKFZLjB/+D37M1C9NTblIwBnS92PbHONC9CzTrtv19bNvNE8D/DFxpbX+1Acx9kl5va+EjoH8buLhua/IecLkDDD/pkiE5kp+WUCgA72f0TTlg8BboXXPn1jrH6QOQoVkt3wAHh8BEkbLXPd7d0zm3f3ta8/sBb1lypWgHKyMAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfoBBsBMh5S5kY0AAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAAeVJREFUWMOtl62SgzAQx/+56UyRPMa5q0T2MZCRlZWVlX2EypV5hJOVkch7DOS6PVGgIZOQBNiZnWEIyf6yXwkK5SKR92rFWkWTBADYe1ltBPnKNc4R47Y3EBGICGxvljy0WoQGZUcBiO2N+GJ7IyUQKhNgEu0OSNiOUmp1TkQ9MOxK5G11tvvQ2J6hEADCr48CEOYuCsDcZQMcMsMk+M0nPh5/9k3CkNrezLywNhkPObVPgYGmbmF7g1Nkx6fq211DrQEQAtAGBozz3PFfFGKE1wmIaObzgpITijEcY/Ixd1MIeF5F64xTAsIFGdVfJxciaJwSHqFAkpLTMd3umeqEwoE4u9IWlpAZuid9uqhaBAi1XdoA4J2YKucsEC+DN0OYyO5jx7FyDVLgEDI7djmVaj5t4NJR4g3jwef0g1nm00Km+xm/9F2sDL9yY9gON6JQW9aDl6rh+fm6grkDc4dYKy+9kk1xH0F4AQgAyBLIUjJMKucWVNIL/Jh7Sax2ASiBwVqAUMavFb1gK3Qcy7V5oNbNe/LlvAlCJ0oveSW7P1/QlzNKPaIz6z4aAtcLE4wDkgM+fK+2XkoBADdd435JQ4/Sk938YzLzwk3XqKpTck7pj0/SA+NOHmj2/tnNmiBbDaTkH10zqfNKfmQ4AAAAAElFTkSuQmCC',
                    empty: new Image(),
                    beeper: new Image(),
                    karel: new Image(),
                    imgw: 40,
                    imgh: 40,
                    bg: '#FDB'
                },
                "frog": {
                    empty_img: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAABhWlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw1AUhU/TiiIVEYuIOmSoTnZREcdSxSJYKG2FVh1MXvoHTRqSFBdHwbXg4M9i1cHFWVcHV0EQ/AFxdnBSdJES70sKLWK88Hgf591zeO8+QGhUmGoGooCqWUYqHhOzuVWx+xUBjMKHIQxIzNQT6cUMPOvrnjqp7iI8y7vvz+pT8iYDfCJxlOmGRbxBPLtp6Zz3iUOsJCnE58STBl2Q+JHrsstvnIsOCzwzZGRS88QhYrHYwXIHs5KhEs8QhxVVo3wh67LCeYuzWqmx1j35C4N5bSXNdVpjiGMJCSQhQkYNZVRgIUK7RoqJFJ3HPPwjjj9JLplcZTByLKAKFZLjB/+D37M1C9NTblIwBnS92PbHONC9CzTrtv19bNvNE8D/DFxpbX+1Acx9kl5va+EjoH8buLhua/IecLkDDD/pkiE5kp+WUCgA72f0TTlg8BboXXPn1jrH6QOQoVkt3wAHh8BEkbLXPd7d0zm3f3ta8/sBb1lypWgHKyMAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfoBBsBGjNKZLTrAAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAADhJREFUSMft0bEJADAMA0GRiTxKxsrWcpMylVMYzB+oFkISAAAA8OCbklUtta04Wz/lLYv5mI/nSQ8KFAP/WXxQAAAAAElFTkSuQmCC',
                    beeper_img: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAABhWlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw1AUhU/TiiIVEYuIOmSoTnZREcdSxSJYKG2FVh1MXvoHTRqSFBdHwbXg4M9i1cHFWVcHV0EQ/AFxdnBSdJES70sKLWK88Hgf591zeO8+QGhUmGoGooCqWUYqHhOzuVWx+xUBjMKHIQxIzNQT6cUMPOvrnjqp7iI8y7vvz+pT8iYDfCJxlOmGRbxBPLtp6Zz3iUOsJCnE58STBl2Q+JHrsstvnIsOCzwzZGRS88QhYrHYwXIHs5KhEs8QhxVVo3wh67LCeYuzWqmx1j35C4N5bSXNdVpjiGMJCSQhQkYNZVRgIUK7RoqJFJ3HPPwjjj9JLplcZTByLKAKFZLjB/+D37M1C9NTblIwBnS92PbHONC9CzTrtv19bNvNE8D/DFxpbX+1Acx9kl5va+EjoH8buLhua/IecLkDDD/pkiE5kp+WUCgA72f0TTlg8BboXXPn1jrH6QOQoVkt3wAHh8BEkbLXPd7d0zm3f3ta8/sBb1lypWgHKyMAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfoBBsBGxNoEaViAAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAAN9JREFUSMftlTEOgzAMRX+iSuQ4PUZHxo49To/B2JGRo4XJHRBtSKLUDlarovwFZMAvHzsO0HR0mYpvSCOXkQK9j6LjcnFXWU4umFZg1y2G59kkcAyAm3h5rQTq3DsY3r90A/ylWA4ReOM0cQsAvbxRLMdtEZoRx7WVrDJsrKTJhDpxXvroctT/1cVmSmKDMjjbwYxne/dxdjsBgH/k3XL2MqvGaw03oC/NaipChW7FszqBR83EhdacThQMiBgoymcqS0RKef5LxDmFVGZ1CCUinO899sB/4rjVuNX4eHoCbZFN/iINYbEAAAAASUVORK5CYII=',
                    karel_img: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAABhWlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw1AUhU/TiiIVEYuIOmSoTnZREcdSxSJYKG2FVh1MXvoHTRqSFBdHwbXg4M9i1cHFWVcHV0EQ/AFxdnBSdJES70sKLWK88Hgf591zeO8+QGhUmGoGooCqWUYqHhOzuVWx+xUBjMKHIQxIzNQT6cUMPOvrnjqp7iI8y7vvz+pT8iYDfCJxlOmGRbxBPLtp6Zz3iUOsJCnE58STBl2Q+JHrsstvnIsOCzwzZGRS88QhYrHYwXIHs5KhEs8QhxVVo3wh67LCeYuzWqmx1j35C4N5bSXNdVpjiGMJCSQhQkYNZVRgIUK7RoqJFJ3HPPwjjj9JLplcZTByLKAKFZLjB/+D37M1C9NTblIwBnS92PbHONC9CzTrtv19bNvNE8D/DFxpbX+1Acx9kl5va+EjoH8buLhua/IecLkDDD/pkiE5kp+WUCgA72f0TTlg8BboXXPn1jrH6QOQoVkt3wAHh8BEkbLXPd7d0zm3f3ta8/sBb1lypWgHKyMAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfoBBsBIwts4oHPAAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAAXxJREFUSMftVjuugzAQnI0ihWO8I7ik5Ag5wivpHmWOkNJ0HCFljpCSkiPkGFD5FcEr4x82pGQlBNLaO96d9SzAYYcd9iWjDXtUJIZKjZ8LrMT9CgCoy5/Pu5I6Tsy3C9gJrK2uJGI+Hw7tKPEuSk85u+U4QinFDwB+x3w+O+3pzFjgmG9LNys5jsq0mfugz3g2ccyNNdyeC0f3auxGcnxd/3b20Z5uzrWuf/Phz1tBhSijG4ehR11Jzlp/a3DKKbFZ1lRwO+O55BSSu4UScaDbE+J+zS65xTEB4FIrq0lU6Iq004S6KHaLCPmAfVL42zzwd7lkIbXTBABoPgclr4Bo0oUoV7lLtdhBzzYXtQHevRrUlYQcx6/PY50xmRfc7ka7dDml9pXZq9V8yWdwH/c5/KYMCc6669+O/PEiomjQdppA8y0NZetwHOrqoSp49HHAFd5joMH/Jc9AIO0PDYuFovnXpN1jU95M+fSplknLyhpygHMqElmrUtXrH5MJ+9Szi0ZhAAAAAElFTkSuQmCC',
                    empty: new Image(),
                    beeper: new Image(),
                    karel: new Image(),
                    imgw: 34,
                    imgh: 34,
                    bg: '#DEF'
                },
                "monkey": {
                    empty_img: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAFiUAABYlAUlSJPAAAAB3SURBVChTY/wPBAxEABSFjIyMUBYEIJsBVwhSdCPAAiwIAxobTiAUQxX+Byr6/6OjAMwGYRAbJAZV8h+uEKYIBtDFmIAMCPCQgDKQAJIYQqGGBsOPCx1gt4IwiA0SgwOwuUAAYv74sQHK+w9mI0n/Jz148AMGBgCKC3d6FXE2lQAAAABJRU5ErkJggg==',
                    beeper_img: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASCAYAAABWzo5XAAAAxnpUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHjabVDbDcMwCPz3FB2Blx08jvOo1A06fiGQKImK5AMO+wyU7ft5l5cboRSpk7beGphJl07DAoWwsSOC7BgJZQ3vfDkLZBSb50i1nQ+Dx1Mg3LCoXoR0ycJ8L3RJfX0I5UfsHXkTawr1FGKKAqbAiLGgdZ2uI8wb3E3jFIe2wD4Ipvozl8m2t1b7h4k2RgZD5hYNsB8pPCwQQ7JLTqHF1bzzx0i2kH97Oqz8AEBfWdj2gKqwAAABhWlDQ1BJQ0MgcHJvZmlsZQAAeJx9kTtIw0Acxr8+pCItDhYRdchQnezgA3EsVSyChdJWaNXB5NIXNGlIUlwcBdeCg4/FqoOLs64OroIg+ABxdnBSdJES/5cUWsR4cNyP7+77uPsO8DarTDH8MUBRTT2diAu5/KoQeIUfgwhhEiMiM7RkZjEL1/F1Dw9f76I8y/3cnyMkFwwGeATiGNN0k3iDeHbT1DjvE4dZWZSJz4kndLog8SPXJYffOJds9vLMsJ5NzxOHiYVSF0tdzMq6QjxDHJEVlfK9OYdlzluclWqdte/JXxgsqCsZrtMcRQJLSCIFARLqqKAKE1FaVVIMpGk/7uIftv0pcknkqoCRYwE1KBBtP/gf/O7WKE5POUnBONDzYlkfY0BgF2g1LOv72LJaJ4DvGbhSO/5aE5j7JL3R0SJHQP82cHHd0aQ94HIHGHrSRF20JR9Nb7EIvJ/RN+WBgVugb83prb2P0wcgS10t3wAHh8B4ibLXXd7d293bv2fa/f0A3R1y0YQLRlIAAA12aVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJYTVAgQ29yZSA0LjQuMC1FeGl2MiI+CiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiCiAgICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgICB4bWxuczpHSU1QPSJodHRwOi8vd3d3LmdpbXAub3JnL3htcC8iCiAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgeG1wTU06RG9jdW1lbnRJRD0iZ2ltcDpkb2NpZDpnaW1wOjlkM2E5NjQ3LTVmODItNGM1OC05ZTcxLTlhZjczNDNhYTU0MCIKICAgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpkZDUxN2Q1My1iMjZiLTQ1YmQtYmJmMS0wZGFlZjk5ZWZlYzEiCiAgIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDoxYjYyYzQwYS01ZTc0LTRkODctOTRiMy0zODU3ZjgyNzFiNmEiCiAgIGRjOkZvcm1hdD0iaW1hZ2UvcG5nIgogICBHSU1QOkFQST0iMi4wIgogICBHSU1QOlBsYXRmb3JtPSJXaW5kb3dzIgogICBHSU1QOlRpbWVTdGFtcD0iMTcxMzc5MzkyNjM3NTQyMyIKICAgR0lNUDpWZXJzaW9uPSIyLjEwLjM2IgogICB0aWZmOk9yaWVudGF0aW9uPSIxIgogICB4bXA6Q3JlYXRvclRvb2w9IkdJTVAgMi4xMCIKICAgeG1wOk1ldGFkYXRhRGF0ZT0iMjAyNDowNDoyMlQyMTo1MjowMyswODowMCIKICAgeG1wOk1vZGlmeURhdGU9IjIwMjQ6MDQ6MjJUMjE6NTI6MDMrMDg6MDAiPgogICA8eG1wTU06SGlzdG9yeT4KICAgIDxyZGY6U2VxPgogICAgIDxyZGY6bGkKICAgICAgc3RFdnQ6YWN0aW9uPSJzYXZlZCIKICAgICAgc3RFdnQ6Y2hhbmdlZD0iLyIKICAgICAgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDowYmQ1M2I0Ny1hMmY2LTRkZTgtOTk0ZS00NzE0YzQzMmQyOTYiCiAgICAgIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkdpbXAgMi4xMCAoV2luZG93cykiCiAgICAgIHN0RXZ0OndoZW49IjIwMjQtMDQtMjJUMjE6NTI6MDYiLz4KICAgIDwvcmRmOlNlcT4KICAgPC94bXBNTTpIaXN0b3J5PgogIDwvcmRmOkRlc2NyaXB0aW9uPgogPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgIAo8P3hwYWNrZXQgZW5kPSJ3Ij8+NQsvVgAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAAWJQAAFiUBSVIk8AAAAAd0SU1FB+gEFg00BuygWF0AAADnSURBVDjLrVSxEYMwEJNyTJLMwCyUzEbJENBBkxZKGIEVlMLGsY3xES664zjzj/5flg38CczEdDEPAPA4I5GEqRt80tSThSyRJGnqBvNTK8Uxn6w4GeWIJ4DWpJD0uw1mlySQBN6Wr/zK0mxCvdjFat8VA46kRs0LkARJaDZd2rWdiCRd65cQ5RapnHoBam80N24GSSKUhNkU125IVvGCj9ZwOfdj+KGi0++cKKp0IFkPrnW2KeLALjrJUNg1UyA6Q9rbze7gUZ+0j+Z+NK5NCIoqcDT9RvzRSFK56vGxwC/Xw91r5TY+4Rh8Eh2MH38AAAAASUVORK5CYII=',
                    karel_img: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZCAYAAADE6YVjAAAAxnpUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHjabVDbDcMwCPz3FB2BV4gZx3lU6gYdv9iQKImK5DPcWWeg7N/Pu7x6EEqRaa5qquAhJkbNkwoRbSCCDIzCUsM7X06BnGK/Ocqq+f7g8TSIq3k2XYzqmsJyF0zSvz6M8iPuHZEnWxpZGjGFgGnQYixQq/N1hGWHe9Q4pYOuMAbBdH/WMvv2tsn/YaKdkcGRWaMB7kcKN0/EkfxRp9BzYR28ZSe+kH97OqL8AFY2We82Nzg0AAABhGlDQ1BJQ0MgcHJvZmlsZQAAeJx9kT1Iw0AcxV8/pCItDhYREclQndpFRRxLFYtgobQVWnUwufQLmjQkKS6OgmvBwY/FqoOLs64OroIg+AHi7OCk6CIl/i8ptIjx4Lgf7+497t4B3laNKYY/DiiqqWeSCSFfWBUCr/BjGCFEMS4yQ0tlF3NwHV/38PD1Lsaz3M/9OUJy0WCARyCOM003iTeIZzdNjfM+cZhVRJn4nDiq0wWJH7kuOfzGuWyzl2eG9VxmnjhMLJR7WOphVtEV4hniiKyolO/NOyxz3uKs1Bqsc0/+wmBRXclyneYYklhCCmkIkNBAFTWYiNGqkmIgQ/sJF/+o7U+TSyJXFYwcC6hDgWj7wf/gd7dGaXrKSQomgL4Xy/qYAAK7QLtpWd/HltU+AXzPwJXa9ddbwNwn6c2uFjkCBreBi+uuJu0BlzvAyJMm6qIt+Wh6SyXg/Yy+qQAM3QIDa05vnX2cPgA56mr5Bjg4BCbLlL3u8u7+3t7+PdPp7wfYGXLPnSDscQAADXZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+Cjx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDQuNC4wLUV4aXYyIj4KIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIgogICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgIHhtbG5zOkdJTVA9Imh0dHA6Ly93d3cuZ2ltcC5vcmcveG1wLyIKICAgIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIgogICAgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIgogICB4bXBNTTpEb2N1bWVudElEPSJnaW1wOmRvY2lkOmdpbXA6NzEwNDY2ODQtZDA4ZC00Zjc1LWE2MWItOGYwYmUzNjY4ZjVkIgogICB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOmZhYWY4NDdiLTBiYzMtNGFlMi1iODQ4LTExMzZjZGZlNzU3MyIKICAgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ4bXAuZGlkOmY2OTI2OGU1LTliNTItNDE0Mi1hYTc4LTljOWE2ZTZhZTFjMyIKICAgZGM6Rm9ybWF0PSJpbWFnZS9wbmciCiAgIEdJTVA6QVBJPSIyLjAiCiAgIEdJTVA6UGxhdGZvcm09IldpbmRvd3MiCiAgIEdJTVA6VGltZVN0YW1wPSIxNzEzNzkzNTcxNTA3NzE4IgogICBHSU1QOlZlcnNpb249IjIuMTAuMzYiCiAgIHRpZmY6T3JpZW50YXRpb249IjEiCiAgIHhtcDpDcmVhdG9yVG9vbD0iR0lNUCAyLjEwIgogICB4bXA6TWV0YWRhdGFEYXRlPSIyMDI0OjA0OjIyVDIxOjQ2OjA5KzA4OjAwIgogICB4bXA6TW9kaWZ5RGF0ZT0iMjAyNDowNDoyMlQyMTo0NjowOSswODowMCI+CiAgIDx4bXBNTTpIaXN0b3J5PgogICAgPHJkZjpTZXE+CiAgICAgPHJkZjpsaQogICAgICBzdEV2dDphY3Rpb249InNhdmVkIgogICAgICBzdEV2dDpjaGFuZ2VkPSIvIgogICAgICBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOmI4YjA4NWNiLTY4MjItNGJmNi05ZGVlLWFhZTJiNTA5NTYzZiIKICAgICAgc3RFdnQ6c29mdHdhcmVBZ2VudD0iR2ltcCAyLjEwIChXaW5kb3dzKSIKICAgICAgc3RFdnQ6d2hlbj0iMjAyNC0wNC0yMlQyMTo0NjoxMSIvPgogICAgPC9yZGY6U2VxPgogICA8L3htcE1NOkhpc3Rvcnk+CiAgPC9yZGY6RGVzY3JpcHRpb24+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz65E2CAAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAB3RJTUUH6AQWDS4LIjzeOwAAAVdJREFUSMflVSGWxCAMTfpG5AgrRyIrK1eu5CiVlZXIOQpyjlBZWTlyjhDHihYGKPAYdtUu7/EIgfY3P/kpwH8cpvXBSwNACQyrnSWwTQ5ucx2G4JCmW/K9XTPALAHGz30eg1nDTyIxAAAW5DrL3StE8jKRDN5dE4nhVQGvCoRezhSRTNpNdD1mDazGpuqqBhF6eW3uz33dtiAP1j5W05L4VBUBbFvyjg+EmfrHVF7g/gSabi/avj6icEWyADoPAL0ZCw6pn86fe9BG/QTUT3tUx4wrzLzRRgyr0RxnbvKqDK8q9ge0GA8xZwfArMYzVZaiPWIsgfgRYE7xQaVVCLz01dmW4pd1BIwlnWCKy1zPspGwGgM7l98uigrjpPqXbc9i1iD0Ao9lcUDWTgFhbXOMhUYkA7X7+7h8LzXNMRYakQTn/83e5YSW8DnQhAhr6Gr5ryP82fENnW6vnRrfvVkAAAAASUVORK5CYII=',
                    empty: new Image(),
                    beeper: new Image(),
                    karel: new Image(),
                    imgw: 25,
                    imgh: 25,
                    bg: '#FFF'
                }
            }
            // set the default to the first style
            let style = styles[Object.keys(styles)[0]]
            let timeout_ms = 500
            const constants = {
                // directions
                right: 0,
                down: 1,
                left: 2,
                up: 3,
                functions: {
                    'move': true,
                    'turn_left': true,
                    'put_beeper': true,
                    'pick_beeper': true
                },
                conditions: {
                    'front_is_clear': true,
                    'front_is_blocked': true,
                    'beepers_present': true,
                    'no_beepers_present': true,
                    'left_is_clear': true,
                    'left_is_blocked': true,
                    'right_is_clear': true,
                    'right_is_blocked': true,
//beepers_in_bag()	no_beepers_in_bag()	Does Karel have any beepers in its bag?
                    'facing_north': true,
                    'not_facing_north': true,
                    'facing_south': true,
                    'not_facing_south': true,
                    'facing_east': true,
                    'not_facing_east': true,
                    'facing_west': true,
                    'not_facing_west': true
                },
                playground_buttons: [
                    "move_button",
                    "turn_button",
                    "put_button",
                    "pick_button",
                    "reset_button"
                ],
                code_buttons: [
                    "rewind_button",
                    "play_back_button",
                    "back_button",
                    "forward_button",
                    "play_button",
                    "fast_forward_button"
                ]
            }
            // dimensions of the world
            let cols = 15
            let rows = 6
            let initial_state = {
                kcol: 0,
                krow: rows - 1,
                kdir: constants.right,
                grid_string: JSON.stringify(Array(rows).fill(Array(cols).fill(0)))
            }
            var canv, ctx
            function setup_state() {
                let state = {
                    grid: JSON.parse(initial_state.grid_string),
                    krow: initial_state.krow,
                    kcol: initial_state.kcol,
                    kdir: initial_state.kdir,
                    prev_tab: "history",
                    code_styled: false,
                    run_history: [],
                    run_history_pos: 0,
                    backup: null,
                    code: {
                        unparsed: [],
                        parsed: [],
                        timer: null,
                        timer_f: null,
                        pos: 0,
                        load: load_code,
                        stack: [],
                        vars: {}
                    },
                    controls: {
                        play: run_play,
                        play_back: run_play_back,
                        pause: run_pause,
                        rewind: run_rewind,
                        fast_forward: run_fast_forward,
                        forward: run_forward,
                        back: run_back
                    },
                    reset_karel: () => {
                        // state.grid = JSON.parse(initial_state.grid_string)
                        state.krow = initial_state.krow
                        state.kcol = initial_state.kcol
                        state.kdir = initial_state.kdir
                        refresh()
                    },
                    backup_state: () => {
                        state.backup = [
                            JSON.stringify(state.grid),
                            state.krow,
                            state.kcol,
                            state.kdir
                        ]
                    },
                    restore_state: () => {
                        state.grid = JSON.parse(state.backup[0])
                        state.krow = state.backup[1]
                        state.kcol = state.backup[2]
                        state.kdir = state.backup[3]
                        refresh()
                    },
                    backup_restore: () => {
                        let backup = [
                            JSON.stringify(state.grid),
                            state.krow,
                            state.kcol,
                            state.kdir
                        ]
                        if(state.backup) {
                            state.restore_state()
                        }
                        state.backup = backup
                    },
                    render_history: render_history
                }
                function history_string(command) {
                    if(command.type == "call") {
                        return command.id + "()"
                    }
                    else {
                        return "-"
                    }
                }
                function render_history() {
                    let h = state.run_history.map((stuff) => {
                        return history_string(state.code.parsed[stuff.pos])
                    })
                    return " " + h.slice(0, state.run_history_pos).join("\n ") +
                         "\n>" + h.slice(state.run_history_pos).join("\n ")
                }
                function run_forward() {
                    // not sure if this can happen.
                    if(state.code.parsed.length == 0) {
                        error("SOMEHOW RUNNING BEFORE CODE PROPERLY PARSED")
                        return
                    }
                    
                    // there is always a noop code at the end
                    if(state.code.pos >= state.code.parsed.length - 1) {
                        state.code.pos = state.code.parsed.length - 1
                        run_pause()
                        return
                    }

                    // TODO: this might push errored stuff into the history
                    // that doesn't actually execute, not sure if htat's good or bad
                    state.run_history.splice(state.run_history_pos) // maybe not necessary, was for playground
                    state.run_history.push({
                        pos: state.code.pos,
                        stack: JSON.stringify(state.code.stack),
                        vars: JSON.stringify(state.code.vars)
                    })
                    state.run_history_pos++

                    let command = state.code.parsed[state.code.pos]

                    if(command.type == "call") {
                        let err = try_call(command.id)
                        if(!err) {
                            state.code.pos++
                        }
                    }
                    else if(command.type == "for") {
                        if(!state.code.vars.hasOwnProperty(command.var)) {
                            state.code.vars[command.var] = command.count
                        }
                        state.code.vars[command.var]--
                        if(state.code.vars[command.var] < 0) {
                            delete state.code.vars[command.var]
                            state.code.pos = command.end
                        }
                        else {
                            state.code.stack.push(state.code.pos)
                            state.code.pos++
                        }
                    }
                    else if(command.type == "if" || command.type == "while") {
                        let res = try_test(command.test)
                        if(res) {
                            state.code.stack.push(state.code.pos)
                            state.code.pos++
                        }
                        else {
                            state.code.pos = command.end
                        }
                    }
                    else if(command.type == "else") {
                        // this code runs when the if test fails
                        state.code.stack.push(state.code.pos)
                        state.code.pos++
                    }
                    else {
                        // skip over both errors and empty lines
                        state.code.pos++
                    }
                    // whiles jump back to check
                    let next_command = state.code.parsed[state.code.pos]
                    if(state.code.stack.length > next_command.indent) {
                        let last_line = state.code.stack[state.code.stack.length - 1]
                        let last_command = state.code.parsed[last_line]
                        state.code.stack.pop()
                        if(last_command.type == "while" || last_command.type == "for") {
                            state.code.pos = last_line
                        }
                        else if(last_command.type == "if") {
                            if(next_command.type == "else") {
                                state.code.pos = next_command.end
                            }
                        }
                    }
                    style_code(state.code.pos)
                    refresh()
                }
                // TODO: change other code with run forward not being actually execute
                // since that functionality has been removed
                function run_back() {
                    if(state.run_history_pos == 0) {
                        // this seems like an ugly hack
                        // for the specific case when you have a conditional check at the start of the program
                        // TODO maybe??? put checks in the call history?
                        // next two lines may be a hack
                        state.code.pos = 0
                        refresh() // to show current code position
                        run_pause()
                        return
                    }
                    let stuff = state.run_history[--state.run_history_pos]
                    let command = state.code.parsed[stuff.pos]
                    if(command.type == "call") {
                        try_undo(command.id)
                    }
                    state.code.pos = stuff.pos
                    state.code.stack = JSON.parse(stuff.stack)
                    state.code.vars = JSON.parse(stuff.vars)
                    refresh()
                }
                function run_rewind() {
                    while(state.run_history_pos > 0) {
                        run_back()
                    }
                    // needed since checks are not in the call history?
                    state.code.pos = 0
                    refresh()
                }
                function run_fast_forward() {
                    for(let limit = 1000; limit > 0; limit--) {
                        run_forward()
                    }
                    refresh()
                }
                function run_play() {
                    state.timer_f = run_forward
                    state.timer = setInterval(run_forward, timeout_ms)
                    style_code(state.code.pos)
                }
                function run_play_back() {
                    state.timer_f = run_back
                    state.timer = setInterval(run_back, timeout_ms)
                }
                function run_pause() {
                    if(state.timer_f) {
                        state.timer_f = null
                        clearInterval(state.timer)
                    }
                }
                function parse() {
                    // changed from jumps to stack implementation
                    let spaces = state.code.unparsed.map((line) => {
                        let sps = 0
                        while(sps < line.length && line[sps] == " ") {
                            sps++
                        }
                        return sps
                    })
                    let indents = []
                    let indent_stack = [0]
                    // todo: make sure code is indented back to margin if it isn't already
                    // maybe do this after code is edited  in field by user
                    for(let i = 0; i < spaces.length; i++) {
                        if(spaces[i] > indent_stack[indent_stack.length - 1]) {
                            indent_stack.push(spaces[i])
                        }
                        else if(indent_stack.length > 1) {
                            while(spaces[i] <= indent_stack[indent_stack.length - 2]) {
                                indent_stack.pop()
                            }
                        }
                        indents[i] = indent_stack.length - 1
                    }
                    function find_block_end(start) {
                        let res
                        for(res = start + 1; res < spaces.length && spaces[res] > spaces[start]; res++);
                        return res
                    }
                    state.code.parsed = []
                    for(let i = 0; i < state.code.unparsed.length; i++) {
                        let line = state.code.unparsed[i].trim()
                        let index = line.length - 2
                        if(line.substring(index) == "()" && constants.functions[line.substring(0, index)]) {
                            if(constants.functions[line.substring(0, index)]) {
                                res = {type: "call", id: line.substring(0, index)}
                            }
                            else {
                                res = {type: "error"}
                            }
                        }
                        else if(line.startsWith("if ")) {
                            test = line.substring(3, line.length - 3)
                            if(constants.conditions[test]) {
                                res = {type: "if", test: test, end: find_block_end(i)}
                            }
                            else {
                                res = {type: "error"}
                            }
                        }
                        else if(line.startsWith("else")) {
                            res = {type: "else", end: find_block_end(i)}
                        }
                        else if(line.startsWith("for ")) {
                            let words = line.split(" ")
                            if(words.length == 4 && words[3].length >= 9) {
                                let num_string = (words[3]).substring(6, words[3].length - 2)
                                let count = parseInt(num_string)
                                res = {type: "for", var: words[1], count: count, end: find_block_end(i)}
                            }
                            else {
                                res = {type: "error"}
                            }
                            console.log("forrr")
                        }
                        else if(line.startsWith("while ")) {
                            test = line.substring(6, line.length - 3)
                            if(constants.conditions[test]) {
                                res = {type: "while", test: test, end: find_block_end(i)}
                            }
                            else {
                                res = {type: "error"}
                            }
                        }
                        else if(line == "") {
                            res = {type: "noop"}
                        }
                        else {
                            res = {type: "error"}
                        }
                        res["indent"] = indents[i]
                        state.code.parsed.push(res)
                    }
                }
                function load_code(code) {
                    state.code.unparsed = code.split("\n")
                    parse()
                }
                return state
            }
            var state = setup_state()
            function error(msg) {
                console.log("ERROR - " + msg)
                state.timer_f = null
                clearInterval(state.timer)
            }
            function draw(img, col, row, dir = constants.right) {
                if(dir == constants.down) {
                    angle = Math.PI / 2;
                }
                else if(dir == constants.left) {
                    angle = Math.PI;
                }
                else if(dir == constants.up){
                    angle = Math.PI * 3 / 2;
                }
                else {
                    angle = 0;
                }
                ctx.save()
                ctx.translate(style.imgw * (col + .5), style.imgh * (row + .5))
                ctx.rotate(angle)
                ctx.translate(-.5 * img.width, -.5 * img.height)
                // ctx.scale(ratio, ratio)
                ctx.drawImage(img, 0, 0)
                ctx.restore()
            }
            function draw_grid() {
                ctx.fillStyle = style.bg // maybe move to when style changes or something
                ctx.fillRect(0, 0, canv.width, canv.height)
                for(let row = 0; row < rows; row++) {
                    for(let col = 0; col < cols; col++) {
                        if(state.grid[row][col] == 0) draw(style.empty, col, row)
                        else draw(style.beeper, col, row)
                    }
                }
            }
            function draw_karel() {
                draw(style.karel, state.kcol, state.krow, state.kdir)
            }
            function try_undo(id) {
                // might add error check later
                if(id == "move") {
                    if(state.kdir == constants.right) {
                        state.kcol -= 1
                    }
                    else if(state.kdir == constants.down) {
                        state.krow -= 1
                    }
                    else if(state.kdir == constants.left) {
                        state.kcol += 1
                    }
                    else {
                        state.krow += 1
                    }
                }
                else if(id == "turn_left") {
                    state.kdir = (state.kdir + 1) % 4
                }
                else if(id == "put_beeper") {
                    if(state.grid[state.krow][state.kcol] == 0) {
                        error("NO BEEPERS TO UNDO PUT")
                        return true
                    }
                    state.grid[state.krow][state.kcol]--
                }
                else if(id == "pick_beeper") {
                    state.grid[state.krow][state.kcol]++
                }
            }
            function front_is_clear() {
                if(state.kdir == constants.right && state.kcol >= cols - 1) {
                    return false
                }
                else if(state.kdir == constants.down && state.krow >= rows - 1) {
                    return false
                }
                else if(state.kdir == constants.left && state.kcol <= 0) {
                    return false
                }
                else if(state.krow <= 0) {
                    return false
                }
                return true

            }
            function try_call(id) {
                if(id == "move") {
                    if(!front_is_clear()) {
                        error("FRONT IS NOT CLEAR")
                        return true
                    }
                    if(state.kdir == constants.right) {
                        state.kcol += 1
                    }
                    else if(state.kdir == constants.down) {
                        state.krow += 1
                    }
                    else if(state.kdir == constants.left) {
                        state.kcol -= 1
                    }
                    else {
                        state.krow -= 1
                    }
                    
                }
                else if(id == "turn_left") {
                    state.kdir = (state.kdir + 3) % 4
                }
                else if(id == "put_beeper") {
                    state.grid[state.krow][state.kcol]++
                }
                else if(id == "pick_beeper") {
                    if(state.grid[state.krow][state.kcol] == 0) {
                        error("NO BEEPERS TO PICK")
                        return true
                    }
                    state.grid[state.krow][state.kcol]--
                }
            }
            function try_test(test) {
                if(test == "front_is_clear") {
                    return front_is_clear()
                }
                else if(test == "front_is_blocked") {
                    return !front_is_clear()
                }
                else if(test == "beepers_present") {
                    return state.grid[state.krow][state.kcol] > 0
                }
                else if(test == "no_beepers_present") {
                    return state.grid[state.krow][state.kcol] == 0
                }
                else if(test == "front_is_blocked") {
                    return !front_is_clear()
                }
                else if(test == "left_is_clear") {
                    state.kdir--
                    res = front_is_clear()
                    state.kdir++
                    return res
                }
                else if(test == "left_is_blocked") {
                    state.kdir--
                    res = !front_is_clear()
                    state.kdir++
                    return res
                }
                else if(test == "right_is_clear") {
                    state.kdir++
                    res = front_is_clear()
                    state.kdir--
                    return res
                }
                else if(test == "right_is_blocked") {
                    state.kdir++
                    res = !front_is_clear()
                    state.kdir--
                    return res
                }
                else if(test == "facing_north") {
                    return state.kdir == constants.up
                }
                else if(test == "not_facing_north") {
                    return state.kdir == !constants.up
                }
                else if(test == "facing_south") {
                    return state.kdir == constants.down
                }
                else if(test == "not_facing_south") {
                    return state.kdir == !constants.down
                }
                else if(test == "facing_east") {
                    return state.kdir == constants.right
                }
                else if(test == "not_facing_east") {
                    return state.kdir == !constants.right
                }
                else if(test == "facing_west") {
                    return state.kdir == constants.left
                }
                else if(test == "not_facing_west") {
                    return state.kdir == !constants.left
                }
// //beepers_in_bag()	no_beepers_in_bag()	Does Karel have any beepers in its bag?
            }
            // add to code and run
            function execute_call(id) {
                let err = try_call(id)
                if(!err) {
                    refresh()
                }
            }
            function click_box(col, row) {
                if(state.grid[row][col] > 0) {
                    state.grid[row][col] = 0
                }
                else {
                    state.grid[row][col] = 1
                }
                refresh()
            }
            function type_char(str) {
                if(str == "w") {
                    execute_call("pick_beeper")
                }
                if(str == "s") {
                    execute_call("put_beeper")
                }
                if(str == "d") {
                    execute_call("move")
                }
                if(str == "a") {
                    execute_call("turn_left")
                }
                if(str == "u") {
                    undo()
                }
                if(str == "r") {
                    redo()
                }
            }
            function refresh() {
                let ta = document.getElementById("ta1")
                let tab = document.getElementById("id_title").value
                if(tab == "history") {
                    ta.value = state.render_history()
                }
                else if(tab == "code" && state.code_styled) {
                    style_code(state.code.pos)
                }
                draw_grid()
                draw_karel()
                
            }
            function load_all_images() {
                var counter = 0
                function waiter() {
                    counter--
                    if(counter == 0) {
                        refresh()
                    }
                }
                Object.keys(styles).forEach((id) => {
                    counter += 3
                    styles[id].empty.src = styles[id].empty_img
                    styles[id].beeper.src = styles[id].beeper_img
                    styles[id].karel.src = styles[id].karel_img
                    styles[id].empty.addEventListener('load', waiter)
                    styles[id].beeper.addEventListener('load', waiter)
                    styles[id].karel.addEventListener('load', waiter)
                })

            }
            function setup() {
                canv = document.getElementById("canv1")
                ctx = canv.getContext("2d");
                
                canv.addEventListener('mousedown', function(e) {
                    const rect = canv.getBoundingClientRect()
                    const col = Math.floor(cols * (e.clientX - rect.left) / rect.width)
                    const row = Math.floor(rows * (e.clientY - rect.top) / rect.height)
                    click_box(col, row)
                })

                onkeypress = function(e) {
                    e = e || window.event
                    var charCode = (typeof e.which == "number") ? e.which : e.keyCode
                    if (charCode > 0) {
                        type_char(String.fromCharCode(charCode))
                    }
                }

                let ta1 = document.getElementById("ta1")
                ta1.onkeypress = function(e) {
                    e.stopPropagation()
                }

                let ss = document.getElementById("style_switcher")
                ss.innerHTML = Object.keys(styles).map((id) => '<option value="' + id + '">' + id + '</option>').join("\n")

                load_all_images()
                change_tab()
                change_fps()
                change_style()
            }
            function change_tab() {
                let old_state
                let tab = document.getElementById("id_title").value
                let ta = document.getElementById("ta1")
                // backup
                if(state.prev_tab == "code") {
                    if(!state.code_styled) {
                        state.code.unparsed = ta.value.split("\n")
                    }
                }
                else if(state.prev_tab == "playground") {
                    // state.restore_state()
                    state.backup_restore()
                }
                
                if(tab == "code") {
                    ta.disabled = false
                    ta.value = state.code.unparsed.join("\n")
                    ta.style.display = "block"
                }
                else if(tab == "history") {
                    ta.disabled = true
                    ta.value = state.render_history()
                    ta.style.display = "block"
                }
                else if(tab == "playground") {
                    // state.backup_state()
                    state.backup_restore()
                    ta.style.display = "none"
                    document.getElementById("td1").width = 0
                }

                if(tab == "playground") {
                    constants.playground_buttons.forEach((id) => {
                        document.getElementById(id).style.display = "inline-block"
                    })
                    constants.code_buttons.forEach((id) => {
                        document.getElementById(id).style.display = "none"
                    })
                }
                else {
                    constants.code_buttons.forEach((id) => {
                        document.getElementById(id).style.display = "inline-block"
                    })
                    constants.playground_buttons.forEach((id) => {
                        document.getElementById(id).style.display = "none"
                    })
                }
                state.prev_tab = tab
                // rewrites text area
                refresh()
            }
            function style_code(marker = -1) {
                let res = []
                for(let i = 0; i < state.code.unparsed.length; i++) {
                    if(i == marker) {
                        symbol = "> " //➡️
                    }
                    else if(state.code.parsed[i].type == "error") {
                        symbol = "X " //❌
                    }
                    else {
                        symbol = "* " //🔹✅
                        // symbol = "* " //🔹
                    }
                    res.push(symbol + state.code.unparsed[i])
                }
                document.getElementById("ta1").value = res.join("\n")
                state.code_styled = true
            }
            function unstyle_code() {
                if(state.code_styled) {
                    let ta = document.getElementById("ta1")
                    ta.value = state.code.unparsed.join("\n")
                    state.code_styled = false
                }
            }
            function edit_code() {
                unstyle_code()
            }
            function change_code() {
                let tab = document.getElementById("id_title").value
                let ta = document.getElementById("ta1")
                if(tab == "code") {
                    // state.reset()

                    // CODE "CLEANING"
                    let lines = ta.value.split("\n")
                    // set indentation of blank lines to be the same as last line
                    for(let i = 1; i < lines.length; i++) {
                        if(lines[i].trim() == "") {
                            let j
                            for(j = 0; j < lines[i-1].length && lines[i-1].charAt(j) == " "; j++);
                            lines[i] = lines[i-1].substring(0, j)
                        }
                    }
                    // require it end in newline at base indentation level
                    // (one reason is for a required noop when needing to loop back for a while loop)
                    if(lines[lines.length - 1].trim() == "") {
                        lines.length = lines.length - 1
                    }
                    lines.push("")
                    ta.value = lines.join("\n")
                    state.code.load(ta.value)
                }
            }
            function change_style() {
                style = styles[document.getElementById("style_switcher").value]
                // TODO: maybe set it once on style change?
                canv.width = style.imgw * cols
                canv.height = style.imgh * rows
                ctx.fillStyle = style.bg
                refresh()
            }
            function change_fps() {
                timeout_ms = 10000 / document.getElementById("fps_field").value
                if(state.timer_f) {
                    clearInterval(state.timer)
                    state.timer = setInterval(state.timer_f, timeout_ms)
                }
            }
            function blurs() {
                let tab = document.getElementById("id_title").value
                if(tab == "code") {
                    style_code()
                }
            }
        </script>
        <table id="tab1" style="width:100%;height:100%">
            <tr>
                <td id="td1" width="16%">
                    <textarea id="ta1" style="width:100%;height:100%" onblur="blurs()" onfocus="edit_code()" onchange="change_code()"></textarea>
                </td>
                <td>
                    <canvas id="canv1" width="900" height="360" style="width:100%;height:100%;border:2px solid #000000;"></canvas>
                </td>
            </tr>
        </table>
        
        <select name="id_title" id="id_title" onchange="change_tab()">
            <option value="code">code</option>
            <option value="history">history</option>
            <option value="playground">playground</option>
          </select>
          <button id="move_button" onclick='execute_call("move")'>move</button>
          <button id="turn_button" onclick='execute_call("turn_left")'>turn_left</button>
          <button id="put_button" onclick='execute_call("put_beeper")'>put_beeper</button>
          <button id="pick_button" onclick='execute_call("pick_beeper")'>pick_beeper</button>
          <button id="reset_button" onclick='state.restore_state()'>reset state to code</button>
          <button id="rewind_button" onclick='state.controls.pause();state.controls.rewind()'>&lt;&lt;</button>
          <button id="play_back_button" onclick='state.controls.pause();state.controls.play_back()'>&lt;=</button>
          <button id="back_button" onclick="state.controls.pause();state.controls.back()">&lt;</button>
          <button id="forward_button" onclick="state.controls.pause();state.controls.forward()">&gt;</button>
          <button id="play_button" onclick='state.controls.pause();state.controls.play()'>=&gt;</button>
          <button id="fast_forward_button" onclick='state.controls.pause();state.controls.fast_forward()'>&gt;&gt;</button>
          <select name="style_switcher" id="style_switcher" onchange="change_style()"></select>
          <label for="fps_field">FPS</label>
          <input type="number" id="fps_field" name="fps_field" onchange="change_fps()" min="1" max="1000" value="10" />
    </body>
</html>