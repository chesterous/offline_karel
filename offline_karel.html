<!DOCTYPE html>
<html>
    <head>
        <title>Offline Karel (one file Karel)</title>
        <style>
            textarea {
                white-space: pre;
                overflow-wrap: normal;
                overflow-x: scroll;
            }
        </style>
    </head>
    <body onload="setup()">
        <script>
            const constants = {
                // canvas pixels per square
                boxw: 60,
                boxh: 60,
                // base 64 encoded images
                empty_img: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAFiUAABYlAUlSJPAAAAB3SURBVChTY/wPBAxEABSFjIyMUBYEIJsBVwhSdCPAAiwIAxobTiAUQxX+Byr6/6OjAMwGYRAbJAZV8h+uEKYIBtDFmIAMCPCQgDKQAJIYQqGGBsOPCx1gt4IwiA0SgwOwuUAAYv74sQHK+w9mI0n/Jz148AMGBgCKC3d6FXE2lQAAAABJRU5ErkJggg==',
                beeper_img: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASCAYAAABWzo5XAAAAxnpUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHjabVDbDcMwCPz3FB2Blx08jvOo1A06fiGQKImK5AMO+wyU7ft5l5cboRSpk7beGphJl07DAoWwsSOC7BgJZQ3vfDkLZBSb50i1nQ+Dx1Mg3LCoXoR0ycJ8L3RJfX0I5UfsHXkTawr1FGKKAqbAiLGgdZ2uI8wb3E3jFIe2wD4Ipvozl8m2t1b7h4k2RgZD5hYNsB8pPCwQQ7JLTqHF1bzzx0i2kH97Oqz8AEBfWdj2gKqwAAABhWlDQ1BJQ0MgcHJvZmlsZQAAeJx9kTtIw0Acxr8+pCItDhYRdchQnezgA3EsVSyChdJWaNXB5NIXNGlIUlwcBdeCg4/FqoOLs64OroIg+ABxdnBSdJES/5cUWsR4cNyP7+77uPsO8DarTDH8MUBRTT2diAu5/KoQeIUfgwhhEiMiM7RkZjEL1/F1Dw9f76I8y/3cnyMkFwwGeATiGNN0k3iDeHbT1DjvE4dZWZSJz4kndLog8SPXJYffOJds9vLMsJ5NzxOHiYVSF0tdzMq6QjxDHJEVlfK9OYdlzluclWqdte/JXxgsqCsZrtMcRQJLSCIFARLqqKAKE1FaVVIMpGk/7uIftv0pcknkqoCRYwE1KBBtP/gf/O7WKE5POUnBONDzYlkfY0BgF2g1LOv72LJaJ4DvGbhSO/5aE5j7JL3R0SJHQP82cHHd0aQ94HIHGHrSRF20JR9Nb7EIvJ/RN+WBgVugb83prb2P0wcgS10t3wAHh8B4ibLXXd7d293bv2fa/f0A3R1y0YQLRlIAAA12aVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJYTVAgQ29yZSA0LjQuMC1FeGl2MiI+CiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiCiAgICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgICB4bWxuczpHSU1QPSJodHRwOi8vd3d3LmdpbXAub3JnL3htcC8iCiAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgeG1wTU06RG9jdW1lbnRJRD0iZ2ltcDpkb2NpZDpnaW1wOjlkM2E5NjQ3LTVmODItNGM1OC05ZTcxLTlhZjczNDNhYTU0MCIKICAgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpkZDUxN2Q1My1iMjZiLTQ1YmQtYmJmMS0wZGFlZjk5ZWZlYzEiCiAgIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDoxYjYyYzQwYS01ZTc0LTRkODctOTRiMy0zODU3ZjgyNzFiNmEiCiAgIGRjOkZvcm1hdD0iaW1hZ2UvcG5nIgogICBHSU1QOkFQST0iMi4wIgogICBHSU1QOlBsYXRmb3JtPSJXaW5kb3dzIgogICBHSU1QOlRpbWVTdGFtcD0iMTcxMzc5MzkyNjM3NTQyMyIKICAgR0lNUDpWZXJzaW9uPSIyLjEwLjM2IgogICB0aWZmOk9yaWVudGF0aW9uPSIxIgogICB4bXA6Q3JlYXRvclRvb2w9IkdJTVAgMi4xMCIKICAgeG1wOk1ldGFkYXRhRGF0ZT0iMjAyNDowNDoyMlQyMTo1MjowMyswODowMCIKICAgeG1wOk1vZGlmeURhdGU9IjIwMjQ6MDQ6MjJUMjE6NTI6MDMrMDg6MDAiPgogICA8eG1wTU06SGlzdG9yeT4KICAgIDxyZGY6U2VxPgogICAgIDxyZGY6bGkKICAgICAgc3RFdnQ6YWN0aW9uPSJzYXZlZCIKICAgICAgc3RFdnQ6Y2hhbmdlZD0iLyIKICAgICAgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDowYmQ1M2I0Ny1hMmY2LTRkZTgtOTk0ZS00NzE0YzQzMmQyOTYiCiAgICAgIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkdpbXAgMi4xMCAoV2luZG93cykiCiAgICAgIHN0RXZ0OndoZW49IjIwMjQtMDQtMjJUMjE6NTI6MDYiLz4KICAgIDwvcmRmOlNlcT4KICAgPC94bXBNTTpIaXN0b3J5PgogIDwvcmRmOkRlc2NyaXB0aW9uPgogPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgIAo8P3hwYWNrZXQgZW5kPSJ3Ij8+NQsvVgAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAAWJQAAFiUBSVIk8AAAAAd0SU1FB+gEFg00BuygWF0AAADnSURBVDjLrVSxEYMwEJNyTJLMwCyUzEbJENBBkxZKGIEVlMLGsY3xES664zjzj/5flg38CczEdDEPAPA4I5GEqRt80tSThSyRJGnqBvNTK8Uxn6w4GeWIJ4DWpJD0uw1mlySQBN6Wr/zK0mxCvdjFat8VA46kRs0LkARJaDZd2rWdiCRd65cQ5RapnHoBam80N24GSSKUhNkU125IVvGCj9ZwOfdj+KGi0++cKKp0IFkPrnW2KeLALjrJUNg1UyA6Q9rbze7gUZ+0j+Z+NK5NCIoqcDT9RvzRSFK56vGxwC/Xw91r5TY+4Rh8Eh2MH38AAAAASUVORK5CYII=',
                karel_img: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZCAYAAADE6YVjAAAAxnpUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHjabVDbDcMwCPz3FB2BV4gZx3lU6gYdv9iQKImK5DPcWWeg7N/Pu7x6EEqRaa5qquAhJkbNkwoRbSCCDIzCUsM7X06BnGK/Ocqq+f7g8TSIq3k2XYzqmsJyF0zSvz6M8iPuHZEnWxpZGjGFgGnQYixQq/N1hGWHe9Q4pYOuMAbBdH/WMvv2tsn/YaKdkcGRWaMB7kcKN0/EkfxRp9BzYR28ZSe+kH97OqL8AFY2We82Nzg0AAABhGlDQ1BJQ0MgcHJvZmlsZQAAeJx9kT1Iw0AcxV8/pCItDhYREclQndpFRRxLFYtgobQVWnUwufQLmjQkKS6OgmvBwY/FqoOLs64OroIg+AHi7OCk6CIl/i8ptIjx4Lgf7+497t4B3laNKYY/DiiqqWeSCSFfWBUCr/BjGCFEMS4yQ0tlF3NwHV/38PD1Lsaz3M/9OUJy0WCARyCOM003iTeIZzdNjfM+cZhVRJn4nDiq0wWJH7kuOfzGuWyzl2eG9VxmnjhMLJR7WOphVtEV4hniiKyolO/NOyxz3uKs1Bqsc0/+wmBRXclyneYYklhCCmkIkNBAFTWYiNGqkmIgQ/sJF/+o7U+TSyJXFYwcC6hDgWj7wf/gd7dGaXrKSQomgL4Xy/qYAAK7QLtpWd/HltU+AXzPwJXa9ddbwNwn6c2uFjkCBreBi+uuJu0BlzvAyJMm6qIt+Wh6SyXg/Yy+qQAM3QIDa05vnX2cPgA56mr5Bjg4BCbLlL3u8u7+3t7+PdPp7wfYGXLPnSDscQAADXZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+Cjx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDQuNC4wLUV4aXYyIj4KIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIgogICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgIHhtbG5zOkdJTVA9Imh0dHA6Ly93d3cuZ2ltcC5vcmcveG1wLyIKICAgIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIgogICAgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIgogICB4bXBNTTpEb2N1bWVudElEPSJnaW1wOmRvY2lkOmdpbXA6NzEwNDY2ODQtZDA4ZC00Zjc1LWE2MWItOGYwYmUzNjY4ZjVkIgogICB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOmZhYWY4NDdiLTBiYzMtNGFlMi1iODQ4LTExMzZjZGZlNzU3MyIKICAgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ4bXAuZGlkOmY2OTI2OGU1LTliNTItNDE0Mi1hYTc4LTljOWE2ZTZhZTFjMyIKICAgZGM6Rm9ybWF0PSJpbWFnZS9wbmciCiAgIEdJTVA6QVBJPSIyLjAiCiAgIEdJTVA6UGxhdGZvcm09IldpbmRvd3MiCiAgIEdJTVA6VGltZVN0YW1wPSIxNzEzNzkzNTcxNTA3NzE4IgogICBHSU1QOlZlcnNpb249IjIuMTAuMzYiCiAgIHRpZmY6T3JpZW50YXRpb249IjEiCiAgIHhtcDpDcmVhdG9yVG9vbD0iR0lNUCAyLjEwIgogICB4bXA6TWV0YWRhdGFEYXRlPSIyMDI0OjA0OjIyVDIxOjQ2OjA5KzA4OjAwIgogICB4bXA6TW9kaWZ5RGF0ZT0iMjAyNDowNDoyMlQyMTo0NjowOSswODowMCI+CiAgIDx4bXBNTTpIaXN0b3J5PgogICAgPHJkZjpTZXE+CiAgICAgPHJkZjpsaQogICAgICBzdEV2dDphY3Rpb249InNhdmVkIgogICAgICBzdEV2dDpjaGFuZ2VkPSIvIgogICAgICBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOmI4YjA4NWNiLTY4MjItNGJmNi05ZGVlLWFhZTJiNTA5NTYzZiIKICAgICAgc3RFdnQ6c29mdHdhcmVBZ2VudD0iR2ltcCAyLjEwIChXaW5kb3dzKSIKICAgICAgc3RFdnQ6d2hlbj0iMjAyNC0wNC0yMlQyMTo0NjoxMSIvPgogICAgPC9yZGY6U2VxPgogICA8L3htcE1NOkhpc3Rvcnk+CiAgPC9yZGY6RGVzY3JpcHRpb24+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz65E2CAAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAB3RJTUUH6AQWDS4LIjzeOwAAAVdJREFUSMflVSGWxCAMTfpG5AgrRyIrK1eu5CiVlZXIOQpyjlBZWTlyjhDHihYGKPAYdtUu7/EIgfY3P/kpwH8cpvXBSwNACQyrnSWwTQ5ucx2G4JCmW/K9XTPALAHGz30eg1nDTyIxAAAW5DrL3StE8jKRDN5dE4nhVQGvCoRezhSRTNpNdD1mDazGpuqqBhF6eW3uz33dtiAP1j5W05L4VBUBbFvyjg+EmfrHVF7g/gSabi/avj6icEWyADoPAL0ZCw6pn86fe9BG/QTUT3tUx4wrzLzRRgyr0RxnbvKqDK8q9ge0GA8xZwfArMYzVZaiPWIsgfgRYE7xQaVVCLz01dmW4pd1BIwlnWCKy1zPspGwGgM7l98uigrjpPqXbc9i1iD0Ao9lcUDWTgFhbXOMhUYkA7X7+7h8LzXNMRYakQTn/83e5YSW8DnQhAhr6Gr5ryP82fENnW6vnRrfvVkAAAAASUVORK5CYII=',
                // the dimensions of the images (when rendering, images centered within a box of this size)
                imgw: 25,
                imgh: 25,
                // directions
                right: 0,
                down: 1,
                left: 2,
                up: 3,
                functions: {
                    'move': true,
                    'turn_left': true,
                    'put_beeper': true,
                    'pick_beeper': true
                },
                conditions: {
                    'front_is_clear': true,
                    'front_is_blocked': true,
                    'beepers_present': true,
                    'no_beepers_present': true,
                    'left_is_clear': true,
                    'left_is_blocked': true,
                    'right_is_clear': true,
                    'right_is_blocked': true,
//beepers_in_bag()	no_beepers_in_bag()	Does Karel have any beepers in its bag?
                    'facing_north': true,
                    'not_facing_north': true,
                    'facing_south': true,
                    'not_facing_south': true,
                    'facing_east': true,
                    'not_facing_east': true,
                    'facing_west': true,
                    'not_facing_west': true
                },
                playground_buttons: [
                    "move_button",
                    "turn_button",
                    "put_button",
                    "pick_button",
                    "reset_button"
                ],
                code_buttons: [
                    "syntax_button",
                    "rewind_button",
                    "play_back_button",
                    "back_button",
                    "forward_button",
                    "play_button",
                    "fast_forward_button"
                ]
            }
            // dimensions of the world
            let cols = 15
            let rows = 6
            let initial_state = {
                kcol: 0,
                krow: rows - 1,
                kdir: constants.right,
                grid_string: JSON.stringify(Array(rows).fill(Array(cols).fill(0)))
            }
            var canv, ctx
            var images = {
                empty: new Image(),
                beeper: new Image(),
                karel: new Image()
            }
            function setup_state() {
                let state = {
                    grid: JSON.parse(initial_state.grid_string),
                    krow: initial_state.krow,
                    kcol: initial_state.kcol,
                    kdir: initial_state.kdir,
                    prev_tab: "history",
                    code_styled: false,
                    call_history: [],
                    call_history_pos: 0,
                    backup: null,
                    code: {
                        unparsed: [],
                        parsed: [],
                        timer: null,
                        pos: 0,
                        load: load_code
                    },
                    controls: {
                        play: run_play,
                        play_back: run_play_back,
                        pause: run_pause,
                        rewind: run_rewind,
                        fast_forward: run_fast_forward,
                        forward: run_forward,
                        back: run_back
                    },
                    reset_karel: () => {
                        // state.grid = JSON.parse(initial_state.grid_string)
                        state.krow = initial_state.krow
                        state.kcol = initial_state.kcol
                        state.kdir = initial_state.kdir
                        refresh()
                    },
                    backup_state: () => {
                        state.backup = [
                            JSON.stringify(state.grid),
                            state.krow,
                            state.kcol,
                            state.kdir
                        ]
                    },
                    restore_state: () => {
                        state.grid = JSON.parse(state.backup[0])
                        state.krow = state.backup[1]
                        state.kcol = state.backup[2]
                        state.kdir = state.backup[3]
                        refresh()
                    },
                    backup_restore: () => {
                        let backup = [
                            JSON.stringify(state.grid),
                            state.krow,
                            state.kcol,
                            state.kdir
                        ]
                        if(state.backup) {
                            state.restore_state()
                        }
                        state.backup = backup
                    },
                    render_history: render_history
                }
                function history_string(h) {
                    if(h.command.type == "call") {
                        return h.command.id + "()"
                    }
                    else {
                        return ""
                    }
                }
                function render_history() {
                    let h = state.call_history.map(history_string)
                    return " " + h.slice(0, state.call_history_pos).join("\n ") +
                         "\n>" + h.slice(state.call_history_pos).join("\n ")
                }
                function run_forward() {
                    if(state.code.pos >= state.code.parsed.length) {
                        run_pause()
                        return
                    }
                    let command = state.code.parsed[state.code.pos]

                    if(command.type == "call") {
                        let err = try_call(command.id)
                        if(!err) {
                            if(state.call_history_pos < state.call_history.length) {
                                state.call_history.length = state.call_history_pos
                            }
                            state.call_history.push({
                                command: command,
                                line: state.code.pos
                            })
                            state.call_history_pos++
                            if(command.hasOwnProperty("next")) {
                                state.code.pos = command.next
                            }
                            else {
                                state.code.pos++
                            }
                            style_code(state.code.pos)
                        }
                    }
                    else if(command.type == "if" || command.type == "while") {
                        let res = try_test(command.test)
                        if(res) {
                            state.code.pos++
                            style_code(state.code.pos)
                        }
                        else {
                            state.code.pos = command.end
                            style_code(state.code.pos)
                        }
                    }
                    else {
                        // skip over both errors and empty lines
                        state.code.pos++
                    }
                    // jumps (while loop return)
                    if(state.code.pos < state.code.parsed.length && command.type != "while") {
                        let next_command = state.code.parsed[state.code.pos]
                        if(next_command.hasOwnProperty("next")) {
                            state.code.pos = next_command.next
                        }
                    }
                    refresh()
                }
                function run_back() {
                    if(state.call_history_pos == 0) {
                        run_pause()
                        return
                    }
                    let call = state.call_history[--state.call_history_pos]
                    if(call.command.type == "call") {
                        try_undo(call.command.id)
                    }
                    state.code.pos = call.line
                    if(state.code_styled) {
                        style_code(0)
                    }
                    refresh()
                }
                function run_rewind() {
                    while(state.call_history_pos > 0) {
                        run_back()
                    }
                    // state.code.pos = 0
                    if(state.code_styled) {
                        style_code(0)
                    }
                    refresh()
                }
                function run_fast_forward() {
                    for(let limit = 1000; limit > 0; limit--) {
                        run_forward()
                    }
                    refresh()
                }
                function run_play() {
                    state.timer = setInterval(run_forward, 500)
                }
                function run_play_back() {
                    state.timer = setInterval(run_back, 500)
                }
                function run_pause() {
                    clearInterval(state.timer)
                }
                function parse() {
                    let required_jumps = state.code.unparsed.map((line) => -1)
                    let spaces = state.code.unparsed.map((line) => {
                        let sps = 0
                        while(sps < line.length && line[sps] == " ") {
                            sps++
                        }
                        return sps
                    })
                    function find_block_end(start) {
                        let res
                        for(res = start + 1; res < spaces.length && spaces[res] > spaces[start]; res++);
                        return res
                    }
                    state.code.parsed = []
                    for(let i = 0; i < state.code.unparsed.length; i++) {
                        let line = state.code.unparsed[i].trim()
                        let index = line.length - 2
                        if(line.substring(index) == "()" && constants.functions[line.substring(0, index)]) {
                            if(constants.functions[line.substring(0, index)]) {
                                res = {type: "call", id: line.substring(0, index)}
                            }
                            else {
                                res = {type: "error"}
                            }
                        }
                        else if(line.startsWith("if ")) {
                            test = line.substring(3, line.length - 3)
                            if(constants.conditions[test]) {
                                res = {type: "if", test: test, end: find_block_end(i)}
                            }
                            else {
                                res = {type: "error"}
                            }
                        }
                        else if(line.startsWith("while ")) {
                            test = line.substring(6, line.length - 3)
                            if(constants.conditions[test]) {
                                res = {type: "while", test: test, end: find_block_end(i)}
                                required_jumps[res.end] = i
                            }
                            else {
                                res = {type: "error"}
                            }
                        }
                        else if(line == "") {
                            res = {type: "noop"}
                        }
                        else {
                            res = {type: "error"}
                        }
                        if(required_jumps[i] != -1) {
                            res["next"] = required_jumps[i]
                        }
                        state.code.parsed.push(res)
                    }
                }
                function load_code(code) {
                    state.code.unparsed = code.split("\n")
                    parse()
                }
                return state
            }
            var state = setup_state()
            function error(msg) {
                console.log("ERROR - " + msg)
                clearInterval(state.timer)
            }
            function draw(img, col, row, dir = constants.right) {
                if(dir == constants.down) {
                    angle = Math.PI / 2;
                }
                else if(dir == constants.left) {
                    angle = Math.PI;
                }
                else if(dir == constants.up){
                    angle = Math.PI * 3 / 2;
                }
                else {
                    angle = 0;
                }
                if(constants.boxw / constants.imgw > constants.boxh / constants.imgh) {
                    ratio = constants.boxh / constants.imgh
                }
                else {
                    ratio = constants.boxw / constants.imgw
                }
                
                let dx = -img.width * ratio / 2
                let dy = -img.height * ratio / 2

                ctx.save()
                ctx.translate(constants.boxw * (col + .5), constants.boxh * (row + .5))
                ctx.rotate(angle)
                ctx.translate(dx, dy)
                ctx.scale(ratio, ratio)
                ctx.drawImage(img, 0, 0);
                ctx.restore();
            }
            function draw_grid() {
                ctx.clearRect(0, 0, constants.boxw * cols, constants.boxh * rows)
                for(let row = 0; row < rows; row++) {
                    for(let col = 0; col < cols; col++) {
                        if(state.grid[row][col] == 0) draw(images.empty, col, row)
                        else draw(images.beeper, col, row)
                    }
                }
            }
            function draw_karel() {
                draw(images.karel, state.kcol, state.krow, state.kdir)
            }
            function try_undo(id) {
                // might add error check later
                if(id == "move") {
                    if(state.kdir == constants.right) {
                        state.kcol -= 1
                    }
                    else if(state.kdir == constants.down) {
                        state.krow -= 1
                    }
                    else if(state.kdir == constants.left) {
                        state.kcol += 1
                    }
                    else {
                        state.krow += 1
                    }
                }
                else if(id == "turn_left") {
                    state.kdir = (state.kdir + 1) % 4
                }
                else if(id == "put_beeper") {
                    if(state.grid[state.krow][state.kcol] == 0) {
                        error("NO BEEPERS TO UNDO PUT")
                        return true
                    }
                    state.grid[state.krow][state.kcol]--
                }
                else if(id == "pick_beeper") {
                    state.grid[state.krow][state.kcol]++
                }
            }
            function front_is_clear() {
                if(state.kdir == constants.right && state.kcol >= cols - 1) {
                    return false
                }
                else if(state.kdir == constants.down && state.krow >= rows - 1) {
                    return false
                }
                else if(state.kdir == constants.left && state.kcol <= 0) {
                    return false
                }
                else if(state.krow <= 0) {
                    return false
                }
                return true

            }
            function try_call(id) {
                if(id == "move") {
                    if(!front_is_clear) {
                        error("FRONT IS NOT CLEAR")
                        return true
                    }
                    if(state.kdir == constants.right) {
                        state.kcol += 1
                    }
                    else if(state.kdir == constants.down) {
                        state.krow += 1
                    }
                    else if(state.kdir == constants.left) {
                        state.kcol -= 1
                    }
                    else {
                        state.krow -= 1
                    }
                    
                }
                else if(id == "turn_left") {
                    state.kdir = (state.kdir + 3) % 4
                }
                else if(id == "put_beeper") {
                    state.grid[state.krow][state.kcol]++
                }
                else if(id == "pick_beeper") {
                    if(state.grid[state.krow][state.kcol] == 0) {
                        error("NO BEEPERS TO PICK")
                        return true
                    }
                    state.grid[state.krow][state.kcol]--
                }
            }
            function try_test(test) {
                if(test == "front_is_clear") {
                    return front_is_clear()
                }
                else if(test == "front_is_blocked") {
                    return !front_is_clear()
                }
                else if(test == "beepers_present") {
                    return state.grid[state.krow][state.kcol] > 0
                }
                else if(test == "no_beepers_present") {
                    return state.grid[state.krow][state.kcol] == 0
                }
                else if(test == "front_is_blocked") {
                    return !front_is_clear()
                }
                else if(test == "left_is_clear") {
                    state.kdir--
                    res = front_is_clear()
                    state.kdir++
                    return res
                }
                else if(test == "left_is_blocked") {
                    state.kdir--
                    res = !front_is_clear()
                    state.kdir++
                    return res
                }
                else if(test == "right_is_clear") {
                    state.kdir++
                    res = front_is_clear()
                    state.kdir--
                    return res
                }
                else if(test == "right_is_blocked") {
                    state.kdir++
                    res = !front_is_clear()
                    state.kdir--
                    return res
                }
                else if(test == "facing_north") {
                    return state.kdir == constants.up
                }
                else if(test == "not_facing_north") {
                    return state.kdir == !constants.up
                }
                else if(test == "facing_south") {
                    return state.kdir == constants.down
                }
                else if(test == "not_facing_south") {
                    return state.kdir == !constants.down
                }
                else if(test == "facing_east") {
                    return state.kdir == constants.right
                }
                else if(test == "not_facing_east") {
                    return state.kdir == !constants.right
                }
                else if(test == "facing_west") {
                    return state.kdir == constants.left
                }
                else if(test == "not_facing_west") {
                    return state.kdir == !constants.left
                }
// //beepers_in_bag()	no_beepers_in_bag()	Does Karel have any beepers in its bag?
            }
            // add to code and run
            function execute_call(id) {
                let err = try_call(id)
                if(!err) {
                    refresh()
                }
            }
            function click_box(col, row) {
                if(state.grid[row][col] > 0) {
                    state.grid[row][col] = 0
                }
                else {
                    state.grid[row][col] = 1
                }
                refresh()
            }
            function type_char(str) {
                if(str == "w") {
                    execute_call("pick_beeper")
                }
                if(str == "s") {
                    execute_call("put_beeper")
                }
                if(str == "d") {
                    execute_call("move")
                }
                if(str == "a") {
                    execute_call("turn_left")
                }
                if(str == "u") {
                    undo()
                }
                if(str == "r") {
                    redo()
                }
            }
            function refresh() {
                let ta = document.getElementById("ta1")
                let tab = document.getElementById("id_title").value
                if(tab == "history") {
                    ta.value = state.render_history()
                }
                draw_grid()
                draw_karel()
            }
            function load_all_images() {
                var counter = 3
                function waiter() {
                    counter--
                    if(counter == 0) {
                        refresh()
                    }
                }
                images.empty.src = constants.empty_img
                images.beeper.src = constants.beeper_img
                images.karel.src = constants.karel_img
                images.empty.addEventListener('load', waiter)
                images.beeper.addEventListener('load', waiter)
                images.karel.addEventListener('load', waiter)

            }
            function setup() {
                canv = document.getElementById("canv1")
                ctx = canv.getContext("2d");
                
                canv.addEventListener('mousedown', function(e) {
                    const rect = canv.getBoundingClientRect()
                    const col = Math.floor(cols * (e.clientX - rect.left) / rect.width)
                    const row = Math.floor(rows * (e.clientY - rect.top) / rect.height)
                    click_box(col, row)
                })

                onkeypress = function(e) {
                    e = e || window.event
                    var charCode = (typeof e.which == "number") ? e.which : e.keyCode
                    if (charCode > 0) {
                        type_char(String.fromCharCode(charCode))
                    }
                }

                var ta1 = document.getElementById("ta1")
                ta1.onkeypress = function(e) {
                    e.stopPropagation()
                }

                load_all_images()
                change_tab()
            }
            function change_tab() {
                let old_state
                let tab = document.getElementById("id_title").value
                let ta = document.getElementById("ta1")
                // backup
                if(state.prev_tab == "code") {
                    if(!state.code_styled) {
                        state.code.unparsed = ta.value.split("\n")
                    }
                }
                else if(state.prev_tab == "playground") {
                    // state.restore_state()
                    state.backup_restore()
                }
                
                if(tab == "code") {
                    ta.disabled = false
                    ta.value = state.code.unparsed.join("\n")
                    ta.style.display = "block"
                }
                else if(tab == "history") {
                    ta.disabled = true
                    ta.value = state.render_history()
                    ta.style.display = "block"
                }
                else if(tab == "playground") {
                    // state.backup_state()
                    state.backup_restore()
                    ta.style.display = "none"
                    document.getElementById("td1").width = 0
                }

                if(tab == "playground") {
                    constants.playground_buttons.forEach((id) => {
                        document.getElementById(id).style.display = "inline-block"
                    })
                    constants.code_buttons.forEach((id) => {
                        document.getElementById(id).style.display = "none"
                    })
                }
                else {
                    constants.code_buttons.forEach((id) => {
                        document.getElementById(id).style.display = "inline-block"
                    })
                    constants.playground_buttons.forEach((id) => {
                        document.getElementById(id).style.display = "none"
                    })
                }
                state.prev_tab = tab
                // rewrites text area
                refresh()
            }
            function style_code(marker = -1) {
                let res = []
                for(let i = 0; i < state.code.unparsed.length; i++) {
                    if(i == marker) {
                        symbol = "> " //➡️
                    }
                    else if(state.code.parsed[i].type == "error") {
                        symbol = "X " //❌
                    }
                    else {
                        symbol = "* " //🔹✅
                        // symbol = "* " //🔹
                    }
                    res.push(symbol + state.code.unparsed[i])
                }
                document.getElementById("ta1").value = res.join("\n")
                state.code_styled = true
            }
            function check_syntax() {
                let tab = document.getElementById("id_title").value
                if(tab != "code") {
                    return
                }
                if(state.code_styled) {
                    document.getElementById("ta1").value = state.code.unparsed.join("\n")
                }
                else {
                    style_code()
                }
            }
            function unstyle_code() {
                if(state.code_styled) {
                    let ta = document.getElementById("ta1")
                    ta.value = state.code.unparsed.join("\n")
                    state.code_styled = false
                }
            }
            function edit_code() {
                unstyle_code()
            }
            function change_code() {
                let tab = document.getElementById("id_title").value
                let ta = document.getElementById("ta1")
                if(tab == "code") {
                    // state.reset()

                    // require it end in newline
                    // (one reason is for a required noop when needing to loop back for a while loop)
                    let lines = ta.value.split("\n")
                    if(lines[lines.length - 1].trim() != "") {
                        lines.push("")
                        ta.value = lines.join("\n")
                    }
                    state.code.load(ta.value)
                }
            }
        </script>
        <table id="tab1" style="width:100%;height:100%">
            <tr>
                <td id="td1" width="16%">
                    <textarea id="ta1" style="width:100%;height:100%" onfocus="edit_code()" onchange="change_code()"></textarea>
                </td>
                <td>
                    <canvas id="canv1" width="900" height="360" style="width:100%;height:100%;border:2px solid #000000;"></canvas>
                </td>
            </tr>
        </table>
        
        <select name="id_title" id="id_title" onchange="change_tab()">
            <option value="code">code</option>
            <option value="history">history</option>
            <option value="playground">playground</option>
          </select>
          <button id="move_button" onclick='execute_call("move")'>move</button>
          <button id="turn_button" onclick='execute_call("turn_left")'>turn_left</button>
          <button id="put_button" onclick='execute_call("put_beeper")'>put_beeper</button>
          <button id="pick_button" onclick='execute_call("pick_beeper")'>pick_beeper</button>
          <button id="reset_button" onclick='state.restore_state()'>reset state to code</button>
          <button id="syntax_button" onclick='check_syntax()'>check syntax</button>
          <button id="rewind_button" onclick='state.controls.rewind()'>&lt;&lt;</button>
          <button id="play_back_button" onclick='state.controls.play_back()'>&lt;=</button>
          <button id="back_button" onclick="state.controls.back()">&lt;</button>
          <button id="forward_button" onclick="state.controls.forward()">&gt;</button>
          <button id="play_button" onclick='state.controls.play()'>=&gt;</button>
          <button id="fast_forward_button" onclick='state.controls.fast_forward()'>&gt;&gt;</button>
    </body>
</html>